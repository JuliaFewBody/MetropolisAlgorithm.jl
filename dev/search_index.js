var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#One-dimensional-Metropolis-walk","page":"Examples","title":"One-dimensional Metropolis-walk","text":"note: Note\nEven in the one-dimensional case, the initial value ​​must be defined as a vector.","category":"section"},{"location":"examples/#Minimal-Working-Example-for-Single-Walker","page":"Examples","title":"Minimal Working Example for Single-Walker","text":"This is a minimal working example for 1-walker x 1000-steps, 1-dimensional Metropolis-walk on the Gaussian distribution function:\n\np(x) = frac1sqrt2pi expleft(-frac12x^2right)\n\n# sampling Gaussian distribution\nusing MetropolisAlgorithm\np(x) = exp(-x[1]^2/2) / sqrt(2*π) \nr₀ = [1.0]\nR = metropolis(p, r₀, n_steps=1000)\n\nConvert from Vector{Vector{Float64}} to Vector{Float64} for plotting R. A histogram of the output trajectory data R should be consistent with the input distribution function p. Consistency is confirmed in another example.\n\n# plotting histogram\nusing CairoMakie\nX = [r[1] for r in R]\nhist(X)\n\nThis is the trajectory of a walker at each step. The histogram above shows the number of these points in each bin.\n\n# plotting trajectory\nusing CairoMakie\nX = [r[1] for r in R]\nY = keys(X)\nlines(X, Y)","category":"section"},{"location":"examples/#Using-Distributions.jl","page":"Examples","title":"Using Distributions.jl","text":"Here is an example of sampling the distribution functions in Distributions.jl.\n\n# distribution\nusing Distributions\nd = Normal(0, 1)\n\n# sampling\nusing MetropolisAlgorithm\nR = metropolis(x -> Distributions.pdf(d,x[1]), [1.0], n_steps=10000, d=1.0)\n\n# reshape for plotting\nX = [r[1] for r in R]\nY = keys(X)  .- 1\n\n# figure\nusing CairoMakie\nfig = Figure(\n  size = (420,600),\n  fontsize = 11,\n  backgroundcolor = :transparent,\n)\n\n# histogram\naxis = Axis(\n  fig[1,1],\n  limits = (-5, 5, 0, 1.1*Distributions.pdf(d,d.μ)),\n  titlesize = 16.5,\n  xlabelsize = 16.5,\n  ylabelsize = 16.5,\n  title = \"Histogram\",\n  xlabel = \"x\",\n  ylabel = \"PDF(x)\",\n  backgroundcolor = :transparent,\n)\nhist!(axis, [first(r) for r in R], label = \"Metropolis\", bins = 50, normalization = :pdf)\nlines!(axis, -50..50, x -> Distributions.pdf(d,x), label = \"Exact\", color=:black)\naxislegend(axis, position = :rt, framevisible = false)\n\n# trajectory\naxis = Axis(\n  fig[2,1],\n  limits = (-5, 5, 0, length(R)),\n  titlesize = 16.5,\n  xlabelsize = 16.5,\n  ylabelsize = 16.5,\n  title = \"Trajectory\",\n  xlabel = \"x\",\n  ylabel = \"steps\",\n  backgroundcolor = :transparent,\n)\nlines!(axis, X, Y, linewidth = 0.3, label = \"Metropolis\")\naxislegend(axis, position = :rt, framevisible = false)\n\n# display\nfig\n\nThe output histograms are consistent with the input distribution functions.\n\n# packages\nusing CairoMakie\nusing Distributions\nusing MetropolisAlgorithm\n\n# initialize\nfig = Figure(\n  size = (1260,600),\n  fontsize = 11,\n  backgroundcolor = :transparent,\n)\n\nfor n in 1:6\n\n    # distribution\n    d = [\n        Normal(0, 1)\n        SymTriangularDist(0, 1)\n        Uniform(0, 1)\n        Gamma(7.5, 1)\n        TriangularDist(0, 1, 0.2)\n        Semicircle(1)\n    ][n]\n    μ = Distributions.mean(d)\n    σ = Distributions.std(d)\n\n    # sampling\n    R = metropolis(x -> Distributions.pdf(d,x[1]), [1.0], n_steps=100000, d=σ)\n\n    # plot\n    axis = Axis(\n      fig[div(n-1,3)+1,rem(n-1,3)+1],\n      limits = (-5*σ+μ, 5*σ+μ, 0, 1.2*maximum(Distributions.pdf(d,x) for x in -5*σ+μ:0.1:5*σ+μ)),\n      titlesize = 16.5,\n      xlabelsize = 16.5,\n      ylabelsize = 16.5,\n      title = \"$d\",\n      xlabel = \"x\",\n      ylabel = \"PDF(x)\",\n      backgroundcolor = :transparent,\n    )\n    hist!(axis, [first(r) for r in R], label = \"Metropolis\", bins = 50, normalization = :pdf)\n    lines!(axis, -50..50, x -> Distributions.pdf(d,x), label = \"PDF\", color=:black)\n    axislegend(axis, position = :rt, framevisible = false)\n\nend\n\nfig","category":"section"},{"location":"examples/#Minimal-Working-Example-for-Multiple-Walkers","page":"Examples","title":"Minimal Working Example for Multiple-Walkers","text":"Allocate memory by yourself for multiple walkers.\n\nusing MetropolisAlgorithm\np(x) = exp(-x[1]^2/2) / sqrt(2*π)\nR = fill([0.0], 10000)\n\nEach step is run without memory allocation for walkers, overwriting the second argument.\n\nmetropolis!(p, R)\nR\n\nUse the For statement to repeat as many times as you like.\n\nfor i in 1:100\n  metropolis!(p, R)\nend\nR\n\nTime evolution to reach equilibrium. The first several steps are not consistent with the correct distribution.\n\nusing MetropolisAlgorithm\n\n# distribution function\np(x) = exp(-x[1]^2/2) / sqrt(2*π)\n\n# figure\nusing CairoMakie\nfig = Figure(size=(1680, 420))\n\n# axis\naxis1 = Axis(fig[1,1], limits=(-5, 5, 0, 1.1*p([0])), title=\"n=0\")\naxis2 = Axis(fig[1,2], limits=(-5, 5, 0, 1.1*p([0])), title=\"n=1\")\naxis3 = Axis(fig[1,3], limits=(-5, 5, 0, 1.1*p([0])), title=\"n=2\")\naxis4 = Axis(fig[1,4], limits=(-5, 5, 0, 1.1*p([0])), title=\"n=100\")\n\n# n = 0\nR = fill(zeros(1), 10000)\nhist!(axis1, [r[1] for r in R], bins=-5:0.1:5, normalization=:pdf)\nlines!(axis1, -5..5, p, color=:black)\n\n# n = 1\nmetropolis!(p, R)\nhist!(axis2, [r[1] for r in R], bins=-5:0.1:5, normalization=:pdf)\nlines!(axis2, -5..5, p, color=:black)\n\n# n = 2\nmetropolis!(p, R)\nhist!(axis3, [r[1] for r in R], bins=-5:0.1:5, normalization=:pdf)\nlines!(axis3, -5..5, p, color=:black)\n\n# n = 100\nfor i in 3:100\n    metropolis!(p, R)\nend\nhist!(axis4, [r[1] for r in R], bins=-5:0.1:5, normalization=:pdf)\nlines!(axis4, -5..5, p, color=:black)\n\n# display\nfig","category":"section"},{"location":"examples/#Three-dimensional-Metropolis-walk","page":"Examples","title":"Three-dimensional Metropolis-walk","text":"Here is an example of sampling a function like an atomic orbital (d-orbital).","category":"section"},{"location":"examples/#Single-Walker","page":"Examples","title":"Single-Walker","text":"# sampling\nusing MetropolisAlgorithm\nψ(r) = r[1] * r[2] * exp(- r[1]^2 - r[2]^2 - r[3]^2)\np(r) = abs2(ψ(r))\nR = metropolis(r -> abs2(ψ(r)), [1.0, 0.0, 0.0], n_steps=50000)\n\n# plot\nusing CairoMakie\nCairoMakie.activate!(type = \"png\")\nfig = Figure(size=(420,420), figure_padding=0)\naxis = Axis(fig[1,1], aspect=1, backgroundcolor=:black, limits=(-2,2,-2,2))\nhidespines!(axis)\nhidedecorations!(axis)\nlines!(axis, [r[1] for r in R], [r[2] for r in R], linewidth=0.1, color=\"#00FFFF\")\nfig","category":"section"},{"location":"examples/#Multiple-Walkers","page":"Examples","title":"Multiple-Walkers","text":"using MetropolisAlgorithm\n\n# distribution function\nψ(r) = r[1] * r[2] * exp(- r[1]^2 - r[2]^2 - r[3]^2)\np(r) = abs2(ψ(r))\n\n# figure\nusing CairoMakie\nCairoMakie.activate!(type = \"png\")\nfig = Figure(size=(1680, 420))\n\n# axis\naxis1 = Axis(fig[1,1], aspect=1, limits=(-2,2,-2,2), backgroundcolor=:black, title=\"n=0\")\naxis2 = Axis(fig[1,2], aspect=1, limits=(-2,2,-2,2), backgroundcolor=:black, title=\"n=1\")\naxis3 = Axis(fig[1,3], aspect=1, limits=(-2,2,-2,2), backgroundcolor=:black, title=\"n=2\")\naxis4 = Axis(fig[1,4], aspect=1, limits=(-2,2,-2,2), backgroundcolor=:black, title=\"n=10\")\nhidespines!(axis1)\nhidespines!(axis2)\nhidespines!(axis3)\nhidespines!(axis4)\nhidedecorations!(axis1)\nhidedecorations!(axis2)\nhidedecorations!(axis3)\nhidedecorations!(axis4)\n\n# n = 0\nR = fill(zeros(3), 10000)\nscatter!(axis1, [r[1] for r in R], [r[2] for r in R], markersize=2, color=\"#00FFFF\")\n\n# n = 1\nmetropolis!(p, R)\nscatter!(axis2, [r[1] for r in R], [r[2] for r in R], markersize=2, color=\"#00FFFF\")\n\n# n = 2\nmetropolis!(p, R)\nscatter!(axis3, [r[1] for r in R], [r[2] for r in R], markersize=2, color=\"#00FFFF\")\n\n# n = 10\nfor i in 1:10\n    metropolis!(p, R)\nend\nscatter!(axis4, [r[1] for r in R], [r[2] for r in R], markersize=2, color=\"#00FFFF\")\n\n# display\nfig","category":"section"},{"location":"#MetropolisAlgorithm.jl","page":"Home","title":"MetropolisAlgorithm.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status)\n\nMinimal implementation of the Metropolis algorithm.","category":"section"},{"location":"#Install","page":"Home","title":"Install","text":"Run the following code to install this package.\n\nimport Pkg; Pkg.add(url=\"https://github.com/JuliaFewBody/MetropolisAlgorithm.jl.git\")","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"Run the following code before each use.\n\nusing MetropolisAlgorithm\n\nHere is a minimal working example for 1-walker x 10000-steps, 2-dimensional Metropolis-walk using metropolis(). This function returns the trajectory as a vector of vectors (points), where the first argument is the (normalized or unnormalized) distribution function, and the second argument is the initial value vector. Optional arguments can be used to set the number of steps, element type (Float32, Float64, etc.), and the maximum step size. \n\nusing MetropolisAlgorithm\np(r) = exp(- r' * r)  # distribution function\nr₀ = [0.0, 0.0]       # initial position\nR = metropolis(p, r₀) # 1-walker x 10000-steps\n\nIn the variational Monte Carlo method (VMC), sampling is performed simultaneously with multiple walkers (rather than just one walker). Here is an example of 10000-walkers x 5-steps, 2-dimensional Metropolis-walk using metropolis!(). This function overwrites its second argument without memory allocation, where the first argument is the (normalized or unnormalized) distribution function, and the second argument is the vector of the initial value vectors. Use the For statement to repeat as many times as you like. Discard the first several steps to ensure equilibrium.\n\nusing MetropolisAlgorithm\np(x) = exp(- x' * x)              # distribution function\nR = [[0.0, 0.0] for i in 1:10000] # initial position(s)\nmetropolis!(p, R)                 # the 1st step of 10000-walkers\nmetropolis!(p, R)                 # the 2nd step of 10000-walkers\nmetropolis!(p, R)                 # the 3rd step of 10000-walkers\nmetropolis!(p, R)                 # the 4th step of 10000-walkers\nmetropolis!(p, R)                 # the 5th step of 10000-walkers\n\nPlease see Examples and API reference for more information.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"Please cite this package, the original paper by Metropolis et al. and the textbook by Thijssen:\n\nN. Metropolis, A. W. Rosenbluth, M. N. Rosenbluth, A. H. Teller, E. Teller, J. Chem. Phys., 21, 1087–1092 (1953),\nJ. M. Thijssen, Computational Physics 2nd edition, (Cambridge University Press, 2007).\n\nfile = open(\"../../CITATION.bib\", \"r\") # hide\ntext = Base.read(file, String) # hide\nclose(file) # hide\nprintln(text) # hide","category":"section"},{"location":"API/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"API/#MetropolisAlgorithm.bin-Tuple{Vector{<:Vector}}","page":"API reference","title":"MetropolisAlgorithm.bin","text":"bin(A::Vector{<:Vector}; number = fill(10,length(first(A))))\n\nThis function creates data for a multidimensional histogram (for testing).\n\nExamples\n\nusing Random\nA = [randn(2) for i in 1:10000]\n\nusing MetropolisAlgorithm\nb = MetropolisAlgorithm.bin(A, number=[10,10])\n\nusing CairoMakie\nX = b.center[1]\nY = b.center[2]\nZ = b.counter\nheatmap(X, Y, Z)\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.count-Tuple{Vector, Vector, Vector{<:Vector}}","page":"API reference","title":"Base.count","text":"count(center::Vector, width::Vector, A::Vector{<:Vector})\n\nThis function counts the number of points in A that fall within the bin defined by center and width.\n\nArguments\n\ncenter::Vector: Center of the bin. A vector of coordinates.\nwidth::Vector: Width of the bin (rectangle, hypercube). A vector of coordinates.\nA::Vector{<:Vector}: Vector of vectors (points). Each child vector is a point.\n\nExamples\n\njulia> count([0], [2], [randn(1) for i in 1:100000]) / 100 # ≈ 68.3% ()\n68.395\n\njulia> count([0], [0.1], [randn(1) for i in 1:100000]) / 100000 / 0.1\n0.3988\n\njulia> exp(0) / sqrt(2*π)\n0.3989422804014327\n\n\n\n\n\n","category":"method"},{"location":"API/#MetropolisAlgorithm.metropolis!-Tuple{Function, Vector{<:Vector}, Vector{<:Real}}","page":"API reference","title":"MetropolisAlgorithm.metropolis!","text":"metropolis!(f::Function, R::Vector{<:Vector}, rini::Vector{<:Real}; type=typeof(first(rini)), d::Real=one(type))\n\nThis function performs many steps for one walker and overwrites the second argument R.\n\nArguments\n\nf::Function: Distribution function. It does not need to be normalized.\nr_ini::Vector{<:Real}: Initial value vector. Even in the one-dimensional case the initial value must be a vector. Each element (point) has the same size as r_ini.\nR::Vector{<:Vector}: Vector of vectors (points). Each element is a point of the trajectory. The first element of R is the same as r_ini.\nn_steps::Int=10^4: Number of steps; this is the length of the output vector R and matches the default used in metropolis.\ntype::Type=typeof(first(r_ini)): Type of trajectory points, e.g. Float32 or Float64.\nd::Real=one(type): Maximum step size. Default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"API/#MetropolisAlgorithm.metropolis!-Tuple{Function, Vector{<:Vector}}","page":"API reference","title":"MetropolisAlgorithm.metropolis!","text":"metropolis!(f::Function, R::Vector{<:Vector}; type=typeof(first(first(R))), d::Real=one(type))\n\nThis function performs one step for many walkers and overwrites the second argument R. Each element of R is a point (not a trajectory).\n\nArguments\n\nf::Function: Distribution function. It does not need to be normalized.\nR::Vector{<:Vector}: Vector of vectors (points). Each element is a point of a walker.\ntype::Type=typeof(first(first(R))): Type of trajectory points, e.g. Float32 or Float64.\nd::Real=one(type): Maximum step size.\n\n\n\n\n\n","category":"method"},{"location":"API/#MetropolisAlgorithm.metropolis-Tuple{Function, Vector{<:Real}}","page":"API reference","title":"MetropolisAlgorithm.metropolis","text":"metropolis(f::Function, rini::Vector{<:Real}; nsteps::Int=10^4, type=typeof(first(r_ini)), d::Real=one(type))\n\nThis function performs many steps for one walker using metropolis!(f, R, r_ini) and returns the trajectory R as a vector of vectors (points) with memory allocation.\n\n\n\n\n\n","category":"method"},{"location":"API/#MetropolisAlgorithm.pdf-Tuple{Vector, Vector, Vector{<:Vector}}","page":"API reference","title":"MetropolisAlgorithm.pdf","text":"pdf(center::Vector, width::Vector, A::Vector{<:Vector})\n\nThis function approximates the probability density function (PDF) with normalizing count(center, width, A). For the Metropolis algorithm, this function is not needed since the distribution function is known. It is used for testing the algorithm.\n\nArguments\n\ncenter::Vector: Center of the bin. A vector of coordinates.\nwidth::Vector: Width of the bin. A vector of coordinates.\nA::Vector{<:Vector}: Vector of vectors (points). Each child vector is a point.\n\nExamples\n\njulia> pdf([0.0], [0.2], [randn(1) for i in 1:1000000])\n0.39926999999999996\n\njulia> exp(0) / sqrt(2*π)\n0.3989422804014327\n\njulia> pdf([0.0, 0.0], [0.2, 0.2], [randn(2) for i in 1:1000000])\n0.15389999999999998\njulia> exp(0) / sqrt(2*π)^2\n0.15915494309189537\n\njulia> pdf([0.0, 0.0, 0.0], [0.2, 0.2, 0.2], [randn(3) for i in 1:1000000])\n0.06162499999999998\n\njulia> exp(0) / sqrt(2*π)^3\n0.06349363593424098\n\n\n\n\n\n","category":"method"}]
}
